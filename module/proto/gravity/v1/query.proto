syntax = "proto3";
package gravity.v1;

// import "cosmos/base/query/v1beta1/pagination.proto";
import "cosmos/base/v1beta1/coin.proto";
import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "gravity/v1/genesis.proto";
import "gravity/v1/gravity.proto";
import "gravity/v1/msgs.proto";

option go_package = "github.com/cosmos/gravity-bridge/module/x/gravity/types";

// Query defines the gRPC querier service
service Query {

  // Module parameters query
  rpc Params(ParamsRequest) returns (ParamsResponse) {
    option (google.api.http).get = "/gravity/v1/params";
  }

  // TODO(levi) ensure routes are REST-ish:

  // get info on individual outgoing data
  rpc SignerSetTx(SignerSetTxRequest) returns (SignerSetTxResponse) {
    option (google.api.http).get = "/gravity/v1/signer_set";
    // TODO(levi) propose:         "/gravity/v1/signer_sets/{nonce}";
  }
  rpc BatchTx(BatchTxRequest) returns (BatchTxResponse) {
    option (google.api.http).get =
        "/gravity/v1/batch_txs/{contract_address}/{nonce}";
  }
  rpc ContractCallTx(ContractCallTxRequest) returns (ContractCallTxResponse) {
    option (google.api.http).get =
        "/gravity/v1/contract_call_txs/{invalidation_id}/{invalidation_nonce}";
  }

  // get collections of outgoing traffic from the bridge
  rpc SignerSetTxs(SignerSetTxsRequest) returns (SignerSetTxsResponse) {
    option (google.api.http).get = "/gravity/v1/signer_sets";
  }
  rpc BatchTxs(BatchTxsRequest) returns (BatchTxsResponse) {
    option (google.api.http).get = "/gravity/v1/batch/batch_txs";
    // TODO(levi) propose:         "/gravity/v1/batch_txs";
  }
  rpc ContractCallTxs(ContractCallTxsRequest)
      returns (ContractCallTxsResponse) {
    option (google.api.http).get = "/gravity/v1/batch/contract_call_txs";
    // TODO(levi) propose:         "/gravity/v1/contract_call_txs";
  }

  // ethereum signature queries so validators can construct valid etherum
  // transactions

  // TODO: can/should we group these into one endpoint?
  rpc SignerSetTxEthereumSignatures(SignerSetTxEthereumSignaturesRequest)
      returns (SignerSetTxEthereumSignaturesResponse) {
    option (google.api.http).get =
        "/gravity/v1/signer_sets/ethereum_signatures";
  }
  rpc BatchTxEthereumSignatures(BatchTxEthereumSignaturesRequest)
      returns (BatchTxEthereumSignaturesResponse) {
    option (google.api.http).get = "/gravity/v1/batch_txs/ethereum_signatures";
  }
  rpc ContractCallTxEthereumSignatures(ContractCallTxEthereumSignaturesRequest)
      returns (ContractCallTxEthereumSignaturesResponse) {
    option (google.api.http).get =
        "/gravity/v1/logic_calls/ethereum_signatures";
  }

  // ^^^^^^^^^^^^ seem okay for now ^^^^^^

  // pending ethereum signature queries for orchestrators to figure out which
  // signatures they are missing
  // TODO: can/should we group this into one endpoint?
  rpc PendingSignerSetTxEthereumSignatures(
      PendingSignerSetTxEthereumSignaturesRequest)
      returns (PendingSignerSetTxEthereumSignaturesResponse) {
    option (google.api.http).get = "/gravity/v1/SignerSetTxs/{address}/pending";
  }
  rpc PendingBatchTxEthereumSignatures(PendingBatchTxEthereumSignaturesRequest)
      returns (PendingBatchTxEthereumSignaturesResponse) {
    option (google.api.http).get = "/gravity/v1/batches/{address}/pending";
  }
  rpc PendingContractCallTxEthereumSignatures(
      PendingContractCallTxEthereumSignaturesRequest)
      returns (PendingContractCallTxEthereumSignaturesResponse) {
    option (google.api.http).get =
        "/gravity/v1/ContractCallTxs/{address}/pending";
  }

  rpc LastSubmittedEthereumEvent(LastSubmittedEthereumEventRequest)
      returns (LastSubmittedEthereumEventResponse) {
    option (google.api.http).get = "/gravity/v1/oracle/event_nonce/{address}";
  }

  // Queries the fees for all pending batches, results are returned in sdk.Coin
  // (fee_amount_int)(contract_address) style
  rpc BatchTxFees(BatchTxFeesRequest) returns (BatchTxFeesResponse) {
    option (google.api.http).get = "/gravity/v1/batches/fees";
  }

  // Query for info about denoms tracked by gravity
  rpc ERC20ToDenom(ERC20ToDenomRequest) returns (ERC20ToDenomResponse) {
    option (google.api.http).get =
        "/gravity/v1/cosmos_originated/erc20_to_denom";
  }
  // Query for info about denoms tracked by gravity
  rpc DenomToERC20(DenomToERC20Request) returns (DenomToERC20Response) {
    option (google.api.http).get =
        "/gravity/v1/cosmos_originated/denom_to_erc20";
  }
  // Query for pending tranfertxs
  rpc PendingSendToEthereums(PendingSendToEthereumsRequest)
      returns (PendingSendToEthereumsResponse) {
    option (google.api.http).get = "/gravity/v1/query_pending_send_to_eth";
  }

  // delegate keys
  rpc DelegateKeysByValidator(DelegateKeysByValidatorAddress)
      returns (DelegateKeysByValidatorAddressResponse) {
    option (google.api.http).get =
        "/gravity/v1/delegate_keys/validator/{validator}";
  }
  rpc DelegateKeysByEthereumSigner(DelegateKeysByEthereumSignerRequest)
      returns (DelegateKeysByEthereumSignerResponse) {
    option (google.api.http).get =
        "/gravity/v1/delegate_keys/ethereum/{ethereum_signer}";
  }
  rpc DelegateKeysByOrchestrator(DelegateKeysByOrchestratorAddress)
      returns (DelegateKeysByOrchestratorAddressResponse) {
    option (google.api.http).get =
        "/gravity/v1/delegate_keys/orchestrator/{orchestrator}";
  }
}

//  rpc Params
message ParamsRequest {}
message ParamsResponse { Params params = 1 [ (gogoproto.nullable) = false ]; }

//  rpc SignerSetTx
message SignerSetTxRequest {
  uint64 nonce = 1; // NOTE: if nonce is zero then return the current
}
message SignerSetTxResponse { SignerSetTx signer_set = 1; }

//  rpc BatchTx
message BatchTxRequest {
  // NOTE: if nonce is zero then return the current / last batch
  string contract_address = 1;
  // TODO(levi) propose rename to 'token_contract' since that's what
  // BatchTx uses or rename BatchTx.token_contract to contract_address
  uint64 nonce = 2;
}
message BatchTxResponse { BatchTx batch = 1; }

//  rpc ContractCallTx
message ContractCallTxRequest {
  bytes invalidation_id = 1;
  uint64 invalidation_nonce = 2;
}
message ContractCallTxResponse { ContractCallTx logic_call = 1; }

// rpc SignerSetTxEthereumSignatures
message SignerSetTxEthereumSignaturesRequest {
  // NOTE: if address is passed, return only the signature from that validator
  uint64 nonce = 1;
  string address = 2; // TODO(levi) propose rename: ethereum_address
}
message SignerSetTxEthereumSignaturesResponse {
  // repeated SignerSetTxSignature confirm = 1;
  // TODO(levi) confirm orchestrator just needs the sigs from all the
  // validators:
  repeated bytes signature = 1;
}

//  rpc SignerSetTxs
message SignerSetTxsRequest {
  int64 count = 1;
  // TODO(levi) propose we drop count or replace it with:
  // cosmos.base.query.v1beta1.PageRequest pagination = 1;
}
message SignerSetTxsResponse { repeated SignerSetTx signer_sets = 1; }

//  rpc BatchTxs
message BatchTxsRequest {
  // TODO(levi) propose consistency: add count or
  // cosmos.base.query.v1beta1.PageRequest pagination = 1;
}
message BatchTxsResponse { repeated BatchTx batches = 1; }

//  rpc ContractCallTxs
message ContractCallTxsRequest {
  // TODO(levi) propose consistency: add count or
  // cosmos.base.query.v1beta1.PageRequest pagination = 1;
}
message ContractCallTxsResponse { repeated ContractCallTx calls = 1; }

// NOTE(levi) pending queries: this is my address; what do I need to sign??
// why orchestrator key? hot, signing thing all the time so validator key can be
// safer

// rpc PendingSignerSetTxEthereumSignatures
message PendingSignerSetTxEthereumSignaturesRequest {
  // NOTE: this is an sdk.AccAddress and can represent either the
  // orchestartor address or the cooresponding validator address
  string address = 1;
}
message PendingSignerSetTxEthereumSignaturesResponse {
  repeated SignerSetTx signer_sets = 1;
}

message PendingBatchTxEthereumSignaturesRequest {
  // NOTE: this is an sdk.AccAddress and can represent either the
  // orchestartor address or the cooresponding validator address
  string address = 1;
}
message PendingBatchTxEthereumSignaturesResponse {
  // Note these are returned with the signature empty
  repeated BatchTx batches = 1;
}

//  rpc PendingContractCallTxEthereumSignatures
message PendingContractCallTxEthereumSignaturesRequest { string address = 1; }
message PendingContractCallTxEthereumSignaturesResponse {
  repeated ContractCallTx calls = 1;
}

message BatchTxFeesRequest {}
message BatchTxFeesResponse {
  repeated cosmos.base.v1beta1.Coin fees = 1 [
    (gogoproto.nullable) = false,
    (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
  ];
}

message ContractCallTxEthereumSignaturesRequest { string address = 1; }
message ContractCallTxEthereumSignaturesResponse {
  // Note these are returned with the signature empty
  // TODO(levi) review rust to ensure we can have bytes repeated ContractCallTx
  // logic_call_confirms = 1;
  repeated bytes signature = 1;
}

message BatchTxEthereumSignaturesRequest {
  uint64 nonce = 1;
  string contract_address = 2;
}
message BatchTxEthereumSignaturesResponse {
  // TODO(levi) review rust to ensure we can have bytes repeated
  // BatchTxSignature confirms = 1;
  repeated bytes signature = 1;
}

message LastSubmittedEthereumEventRequest { string address = 1; }
message LastSubmittedEthereumEventResponse { uint64 event_nonce = 1; }

message ERC20ToDenomRequest { string erc20 = 1; }
message ERC20ToDenomResponse {
  string denom = 1;
  bool cosmos_originated = 2;
}

message DenomToERC20Request { string denom = 1; }
message DenomToERC20Response {
  string erc20 = 1;
  bool cosmos_originated = 2;
}

message DelegateKeysByValidatorAddress { string validator_address = 1; }
message DelegateKeysByValidatorAddressResponse {
  string eth_address = 1;
  string orchestrator_address = 2;
}

message DelegateKeysByEthereumSignerRequest { string ethereum_signer = 1; }
message DelegateKeysByEthereumSignerResponse {
  string validator_address = 1;
  string orchestrator_address = 2;
}

message DelegateKeysByOrchestratorAddress { string orchestrator_address = 1; }
message DelegateKeysByOrchestratorAddressResponse {
  string validator_address = 1;
  string ethereum_signer = 2;
}

// NOTE: if there is no sender address, return all
// TODO: pagination
message PendingSendToEthereumsRequest { string sender_address = 1; }
message PendingSendToEthereumsResponse {
  repeated SendToEthereum batched_send_to_ethereum_txs = 1;
  repeated SendToEthereum unbatched_send_to_ethereum_txs = 2;
}
