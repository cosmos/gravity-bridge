syntax = "proto3";
package peggy.v1;

import "peggy/v1/genesis.proto";
import "peggy/v1/types.proto";
import "peggy/v1/msgs.proto";
import "peggy/v1/pool.proto";
import "peggy/v1/batch.proto";
import "google/api/annotations.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/althea-net/peggy/module/x/peggy/types";

// Query defines the gRPC querier service
service Query {
  // Params queries the parameters that a module is operating under
  rpc Params(QueryParamsRequest) returns (QueryParamsResponse) {
    option (google.api.http).get = "/peggy/v1beta/params";
  }
  
  // Valsets queries valsets in the store. If a nonce is not provided the latest valset is returned
  rpc Valsets(QueryValsetsRequest) returns (QueryValsetsResponse) {
    option (google.api.http).get = "/peggy/v1beta/valset";
  }

  // Confirms returns confirmations of a given type, requires nonce and/or address
  rpc Confirms(QueryConfirmsRequest) returns (QueryConfirmsResponse) {
    option (google.api.http).get = "/peggy/v1beta/{type}/confirm";
  }

  // PendingConfirm returns the last pending confirmation of a given type for a given address
  rpc PendingConfirm(QueryPendingConfirmRequest) returns (QueryPendingConfirmResponse) {
    option (google.api.http).get = "/peggy/v1beta/{type}/confirm/{address}/pending";
  }

  // Returns the last event nonce a given validator voted on
  rpc LastNonce(QueryLastNonceRequest) returns (QueryLastNonceResponse) {
    option (google.api.http).get = "/peggy/v1beta/nonce/{address}";
  }

  // Returns the outgoing tx batches available to be relayed
  rpc OutgoingTxBatches(QueryOutgoingTxBatchesRequest) returns (QueryOutgoingTxBatchesResponse) {
    option (google.api.http).get = "/peggy/v1beta/outgoingtx";
  }

  // Returns the outgoing logic calls available to be relayed
  rpc OutgoingLogicCalls(QueryOutgoingLogicCallsRequest) returns (QueryOutgoingLogicCallsResponse) {
    option (google.api.http).get = "/peggy/v1beta/outgoinglogic";
  }

  // Returns a batch request given a nonce
  // TODO: do we need this?
  rpc BatchRequestByNonce(QueryBatchRequestByNonceRequest) returns (QueryBatchRequestByNonceResponse) {
    option (google.api.http).get = "/peggy/v1beta/batch/{nonce}";
  }

  // ETHDenomToCosmosDenom
  rpc ERC20ToDenom(QueryERC20ToDenomRequest) returns (QueryERC20ToDenomResponse) {
    option (google.api.http).get = "/peggy/v1beta/cosmos_originated/erc20_to_denom";
  }

  // CosmosDenomToEthDenom
  rpc DenomToERC20(QueryDenomToERC20Request) returns (QueryDenomToERC20Response) {
    option (google.api.http).get = "/peggy/v1beta/cosmos_originated/denom_to_erc20";
  }

  // TODO: Simplify the key delegation querying
  rpc GetDelegateKeyByValidator(QueryDelegateKeysByValidatorAddress) returns (QueryDelegateKeysByValidatorAddressResponse) {
    option (google.api.http).get = "/peggy/v1beta/query_delegate_keys_by_validator";
  }
  rpc GetDelegateKeyByEth(QueryDelegateKeysByEthAddress) returns (QueryDelegateKeysByEthAddressResponse) {
    option (google.api.http).get = "/peggy/v1beta/query_delegate_keys_by_eth";
  }
  rpc GetDelegateKeyByOrchestrator(QueryDelegateKeysByOrchestratorAddress) returns (QueryDelegateKeysByOrchestratorAddressResponse) {
    option (google.api.http).get = "/peggy/v1beta/query_delegate_keys_by_orchestrator";
  }
}

// Params
message QueryParamsRequest {}
message QueryParamsResponse { 
  Params params = 1 [(gogoproto.nullable) = false]; 
}

// Valsets
message QueryValsetsRequest { 
  uint64 nonce = 1; 
}
message QueryValsetsResponse { 
  repeated Valset valsets = 1; 
}

// Confirms
message QueryConfirmsRequest { 
  ConfirmType type    = 1;
  uint64      nonce   = 2; 
  string      address = 3; 
}
message QueryConfirmsResponse { 
  repeated google.protobuf.Any confirms = 1 [
    (cosmos_proto.accepts_interface) = "Confirm"
  ];
}

// PendingConfirm
message QueryPendingConfirmRequest {
  ConfirmType type    = 1;
  string      address = 2;
}
message QueryPendingConfirmResponse {
  google.protobuf.Any confirm = 1 [
    (cosmos_proto.accepts_interface) = "Confirm"
  ];
}

// LastNonce
message QueryLastNonceRequest { 
  string address = 1; 
}
message QueryLastNonceResponse {
  uint64 event_nonce = 1;
}

// OutgoingTxBatches
message QueryOutgoingTxBatchesRequest {}
message QueryOutgoingTxBatchesResponse { 
  repeated OutgoingTxBatch batches = 1; 
}

// OutgoingLogicCalls
message QueryOutgoingLogicCallsRequest {}
message QueryOutgoingLogicCallsResponse { 
  repeated OutgoingLogicCall calls = 1; 
}


message QueryBatchRequestByNonceRequest { 
  uint64 nonce = 1; 
  string contract_address = 2; 
}
message QueryBatchRequestByNonceResponse { 
  OutgoingTxBatch batch = 1; 
}

message QueryERC20ToDenomRequest { string erc20 = 1; }
message QueryERC20ToDenomResponse {
  string denom = 1;
}

message QueryDenomToERC20Request { string denom = 1; }
message QueryDenomToERC20Response {
  string erc20 = 1;
}

message QueryDelegateKeysByValidatorAddress { string validator_address = 1; }
message QueryDelegateKeysByValidatorAddressResponse {
  string eth_address = 1;
  string orchestrator_address = 2;
}

message QueryDelegateKeysByEthAddress { string eth_address = 1; }
message QueryDelegateKeysByEthAddressResponse {
  string validator_address = 1;
  string orchestrator_address = 2;
}

message QueryDelegateKeysByOrchestratorAddress { string orchestrator_address = 1; }
message QueryDelegateKeysByOrchestratorAddressResponse {
  string validator_address = 1;
  string eth_address = 2;
}